# hash map

1. 哈希数组，每个位置是一个buckets，每个bucket，有一个value和key（键值对）
2. key可以是任意类型，int float char 甚至class
3. 哈希函数，通过哈希函数将非int类型的关键字转换为index，可以在O（1）时间内随机索引
  哈希值=哈希函数（关键字（任意类型，可以为class））
  好的哈希函数应该具有单射，雪崩效应两个特征
  ->每个哈希值只有一个key
  key分布的越随机，利用率越高，避免哈希冲突
4. 哈希冲突（不同的关键字有相同的哈希值）

## 常见的哈希函数

1. 直接定址法

key本身就是哈希值，（基数排序）类似于y=F（x）

2. 平方取中法
对key进行平方运算，再取中间某几位作为哈希值，适合不清楚key分布，位数不大
3. 折叠法
 将key分割成位数相等的几部分，在进行求和得到哈希值，例如5201314 将
 它分为4组 52 01 03 04 再相加 = 哈希值

4. 除留余数法
key % 哈希表长度， 例如 4 1 6 3 是key， 那么哈希值 = 4%4=0 1%4=1 6%4=2 3%4=3， so 哈希值= 1234

5. 位与法

 哈希数组长度=2的整数次幂，选择 2 的幂作为哈希表长度可以将取模运算转换成二进制位与令 m 等于 2 的k次任何一个数模上 m就相当于取了 m 的二进制的低 k 位

取m的低k位，也就是m mod 2^k的结果。为了做到这一点，你需要把m和n按位对齐，然后对每一位进行&运算。&运算的规则是：如果两个数的同一位都是1，那么结果的同一位也是1；否则结果的同一位是0。

 当m除以2^k时，就相当于将m的二进制表示向右移动k位，然后去掉多余的高位。

例如：
 m = 10101010 & n = 00001111

r = 00001010

这样你就得到了r，它就是m的低k位，也就是m mod 2k的结果。你可以验证一下，r确实等于m除以2k的余数。例如：

m = 10101010 = 170 n = 00001111 = 15 r = 00001010 = 10

m / n = 11 … r

这个方法之所以有效，是因为2^k是一个2的整数次幂，它的二进制表示只有最高位为1，其余位都为0。因此，m mod 2^k就等于m去掉高位后剩下的部分，也就是m和n按位&后得到的部分。

## 解决哈希冲突

- 开放定址法
  
一旦发生冲突找下一个空地址，只要哈希表足够大总能找到一个空的位置并且记录下来作为它的哈希地址公式如下fi(x) = (f(x) + di) mod m这里的 di 是一个数列可以是常数列(1，1，1，...,1)也可以是等差数列(1,2,3,...,m-1)

 哈希表的每个数据就是一个关键字插入之前需要先进行查找如果找到的位置未被插入则执行插入否则找到下一个未被插入的位置进行插入

- 链地址法

如果冲突直接在原数据上链上新数据
哈希表的每个数据保留了一个链表头结点和尾结点插入之前需要先进行查找如果找到的位置链表非空则插入尾结点并且更新尾结点否则生成一个新的链表头结点和尾结点
