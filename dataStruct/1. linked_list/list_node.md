# 链表

## liked list.cpp question

```c++
#include "../utils/common.hpp"

/* 在链表的节点 n0 之后插入节点 P */
void insert(ListNode *n0, ListNode *P) {
    ListNode *n1 = n0->next;//store
    P->next = n1;
    n0->next = P;
}
```

### ListNode *n1 = n0->next;的目的

在给定的函数insert中，ListNode *n1 = n0->next;这一行的目的是为了保存节点n0原本的下一个节点，以便在插入新节点P之后能够正确地连接链表。

1. 如果直接执行``P->next = n1;``和``n0->next = P;``的顺序，会导致链表连接出现问题。假设原本的链表结构是... -> n0 -> n1 -> ...，插入新节点P后，如果先执行``P->next = n1;``，这时P的下一个节点就是n1，然后执行``n0->next = P;``，把n0的下一个节点指向了P，链表变成了``... -> n0 -> P -> n1 -> ...``，正确地插入了新节点P。

2. 但是如果先执行``n0->next = P;``，这时n0的下一个节点指向了P，链表变成了``... -> n0 -> P -> ...``，然后再执行``P->next = n1;``，这时P的下一个节点就是原本的n1，但是由于n0原本的下一个节点n1并没有保存起来，所以无法正确地将P的下一个节点指向n1，导致链表断裂。

### 计算机知道n1的地址为什么无法将P的下一个节点指向n1

```c++
void insert(ListNode *n0, ListNode *P) {
    ListNode *n1 ;
    cout<<n1<<endl;
    n0->next = P;
    cout<<n0->next<<endl;
    cout<<n1<<endl;
    P->next = n1; 
}
```

1. 计算机是可以知道节点n1的地址的，但问题出在执行顺序上。

如果先执行``n0->next = P;``，这时n0的next指针指向了P，链表变成了``... -> n0 -> P -> ...``。然后再执行``P->next = n1;``，这时P的next指针就需要指向n1。但问题是，我们无法通过直接访问P来获取n1的地址。**在这段代码中，并没有提供一种直接获取n1地址的方式。因此，无法将P的next指针直接指向n1**

### void insert (linklist &n0, linklist &p)这样是否可行

1. 函数签名中的参数类型应该与实际的类型匹配。如果你的链表类型是ListNode*指针类型，那么函数参数应该是ListNode*&，而不是linklist&。这样才能正确地传递指针的引用

### 为什么需要dummy和current两个指针

如果您直接在dummy上操作，那么您会改变dummy节点的指针，从而丢失了原始的head节点的引用，这是因为：

dummy节点的指针本来是指向head节点的，也就是链表的第一个节点。
如果您想要删除链表中的某个节点，比如倒数第n个节点，那么您需要找到它的前一个节点，并将其指针指向下下个节点，即跳过要删除的节点。
但是，如果您直接在dummy上操作，那么您就会将dummy节点的指针指向下下个节点，而不是head节点。这样做的话，您就无法访问到原来的head节点，也就无法遍历整个链表了。
因此，为了保持dummy节点的指针不变，您需要使用另一个指针n0来遍历链表，并找到要删除的节点的前一个节点。然后，您才能修改n0节点的指针，从而删除倒数第n个节点

### 为什么需要dummy节点

使用虚拟头节点（dummy节点）的目的是为了简化链表删除操作的逻辑，特别是在删除头节点时。

在原始链表中，删除头节点和删除其他节点需要采取不同的操作。如果没有虚拟头节点，删除头节点时需要特殊处理，并且需要将新的头节点返回。这会导致在代码中出现条件判断和边界处理的复杂性。

通过引入虚拟头节点，可以将删除头节点的情况与删除其他节点的情况统一起来。虚拟头节点的next指针指向原始的头节点，这样始终可以通过dummy->next访问到链表的真正头节点。这样，无论是删除头节点还是其他节点，都可以按照相同的逻辑进行操作，而无需特殊处理。

在removeNthFromEnd函数中，使用虚拟头节点可以简化删除倒数第n个节点的操作。通过将n0指针指向待删除节点的前一个节点，然后更新n0->next的指向，即可删除倒数第n个节点。

因此，使用虚拟头节点可以简化链表删除操作的逻辑，使代码更加清晰和易于理解。

[9,9,9]和[9,9]两个链表相加

第一位9 + 9 +上一节点的进位数= 18，18 / 10 = 1，进位数= 1；18 % 10 = 8  本节点数= 8；

第二位9 + 9 + 上一节点进位数1 = 19， 19 / 10 = 1，进位数=1；19 % 10 = 9 本节点数= 9；

第三位9 + 0 + 上一节点进位数1 = 10，10 / 10 = 1，进位数=1；10 % 10  = 0 本节点数 = 0；

注意这个地方最后一个节点计算完毕，进位数>0 ，所以需要再追加一位。结果值应该是8->9->0->1
